        <!doctype html>
<html lang="en" data-page="iat">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ST-IAT • Learning Disability IAT</title>
  <link rel="stylesheet" href="assets/styles.css" />

  <!-- jsPsych core + CSS (CDN) -->
  <link href="https://unpkg.com/jspsych@7.3.4/css/jspsych.css" rel="stylesheet" />
  <script src="https://unpkg.com/jspsych@7.3.4"></script>

  <!-- Plugins -->
  <script src="https://unpkg.com/@jspsych/plugin-preload@1.1.3"></script>
  <script src="https://unpkg.com/@jspsych/plugin-html-keyboard-response@1.1.3"></script>
  <script src="https://unpkg.com/@jspsych/plugin-categorize-html@1.1.3"></script>
</head>

<body>
  <main>
    <header class="site">
      <div>
        <div class="brand">IAT Task</div>
        <div class="small">Use <span class="kbd">E</span> (left) and <span class="kbd">I</span> (right)</div>
      </div>
      <div class="progress" data-progress></div>
    </header>

    <section class="card">
      <h1>Single-Target IAT</h1>
      <p class="notice warn">
        Do not use the browser back button during the task. If you need to stop, you may close the page.
      </p>

      <div id="jspsych-target"></div>

      <hr />
      <div class="small">Anonymous session code: <span class="kbd" data-session-id></span></div>
    </section>

    <div class="footer-links">
      <a href="exit.html">Exit</a>
      <button class="btn ghost" data-action="reset" type="button">Reset local session</button>
    </div>
  </main>

  <script type="module">
    import "./js/app.js";
    import { updateState } from "./js/state.js";
try {
  const k="__ok__"; localStorage.setItem(k,"1"); localStorage.removeItem(k);
} catch(e) {
  window.location.href = "timeout.html";
}
    /**********************************************************************
     * UI RENDERER (IAT-style header boxes + central stimulus)
     **********************************************************************/
    function renderIATScreen({ leftTitle, leftSub, rightTitle, rightSub, stimulus }) {
      const stimClass = (String(stimulus).length > 14) ? "iat-stimulus small" : "iat-stimulus";
      return `
        <div class="iat-shell">
          <div class="iat-top">
            <div class="iat-cat left">
              <div class="title">${leftTitle}</div>
              ${leftSub ? `<div class="sub">${leftSub}</div>` : ``}
            </div>
            <div class="iat-cat right">
              <div class="title">${rightTitle}</div>
              ${rightSub ? `<div class="sub">${rightSub}</div>` : ``}
            </div>
          </div>

          <div class="iat-stage">
            <div class="${stimClass}">${stimulus}</div>
          </div>

          <div class="iat-keys">
            <div class="k"><span class="iat-kbd">E</span><span class="hint">Left</span></div>
            <div class="k"><span class="hint">Right</span><span class="iat-kbd">I</span></div>
          </div>
        </div>
      `;
    }

    /**********************************************************************
     * CONFIG (edit these lists later with your vetted stimuli)
     **********************************************************************/
    const KEYS = { left: "e", right: "i" };

    const TARGET_LABEL = "Learning Disabilities";
    const ATTR_POS_LABEL = "Pleasant";
    const ATTR_NEG_LABEL = "Unpleasant";

    // Wilson & Scior (2015) structure: 20/20/40/20/40
    const N_BLOCK1 = 20; // attributes only
    const N_BLOCK2 = 20; // combined practice
    const N_BLOCK3 = 40; // combined test (scored)
    const N_BLOCK4 = 20; // swapped practice
    const N_BLOCK5 = 40; // swapped test (scored)

    // Replace these with your exact final word lists.
    // W&S used 5 pleasant + 5 unpleasant; target had 5 target words.
    const TARGET_STIM = [
      "dyslexia", "dysgraphia", "dyscalculia", "learning difficulty", "IEP"
    ];

    const POS_STIM = [
      "happiness", "laughter", "joyful", "rainbow", "sunshine"
    ];

    const NEG_STIM = [
      "sickness", "hatred", "disease", "terrible", "poison"
    ];

    /**********************************************************************
     * HELPERS
     **********************************************************************/
    function shuffle(arr){
      const a = arr.slice();
      for (let i=a.length-1; i>0; i--){
        const j = Math.floor(Math.random()*(i+1));
        [a[i],a[j]] = [a[j],a[i]];
      }
      return a;
    }

    function pickTrials(stimuli, n){
      // sample with replacement if needed
      const out = [];
      for (let i=0; i<n; i++){
        out.push(stimuli[i % stimuli.length]);
      }
      return shuffle(out);
    }

    function computeD_WilsonScior(catTrials, congruentBlockName, incongruentBlockName){
      // Only correct RTs, filter 300–10000ms
      const keep = catTrials.filter(t =>
        (t.block === congruentBlockName || t.block === incongruentBlockName) &&
        t.correct === true &&
        typeof t.rt === "number" &&
        t.rt >= 300 && t.rt <= 10000
      );

      const cong = keep.filter(t => t.block === congruentBlockName).map(t => t.rt);
      const incong = keep.filter(t => t.block === incongruentBlockName).map(t => t.rt);
      const all = cong.concat(incong);

      const mean = arr => arr.reduce((a,b)=>a+b,0) / Math.max(1, arr.length);
      const sd = arr => {
        const m = mean(arr);
        const v = arr.reduce((acc,x)=>acc + (x-m)*(x-m),0) / Math.max(1, arr.length-1);
        return Math.sqrt(v);
      };

      const mCong = mean(cong);
      const mIncong = mean(incong);
      const sdAll = sd(all);

      const D = sdAll > 0 ? (mIncong - mCong) / sdAll : null;

      return {
        D,
        meanCong: Math.round(mCong),
        meanIncong: Math.round(mIncong),
        sdAll: Math.round(sdAll),
        nUsed: keep.length
      };
    }

    /**********************************************************************
     * COUNTERBALANCING (Wilson & Scior: congruent/incongruent order)
     *
     * Two dimensions:
     *  - Which pairing comes first?  (LD+Pleasant first vs LD+Unpleasant first)
     *  - Which side is the TARGET key first? (Left vs Right), then swapped
     **********************************************************************/
    const firstPairing = (Math.random() < 0.5) ? "LD+PLE" : "LD+UNP"; // which mapping in Blocks 2–3
    const secondPairing = (firstPairing === "LD+PLE") ? "LD+UNP" : "LD+PLE"; // mapping in Blocks 4–5

    const targetKeyFirst = (Math.random() < 0.5) ? "left" : "right"; // target key in Blocks 2–3
    const targetKeySecond = (targetKeyFirst === "left") ? "right" : "left"; // swapped in Blocks 4–5

    // For sign interpretation consistent with your excerpt:
    // Positive D should mean faster when LD is paired with Pleasant.
    const CONGRUENT_PAIRING = "LD+PLE";

    function mappingFor(pairing, targetSide){
      // pairing: LD+PLE or LD+UNP
      // targetSide: "left" or "right"
      // Returns: which categories go to left/right keys
      const targetKey = (targetSide === "left") ? KEYS.left : KEYS.right;
      const otherKey  = (targetSide === "left") ? KEYS.right : KEYS.left;

      const pairedIsPleasant = (pairing === "LD+PLE");

      return {
        pairing,
        targetSide,
        leftTitle: "",
        rightTitle: "",
        keyFor: (cat) => {
          // cat: TARGET, POS, NEG
          if (cat === "TARGET") return targetKey;
          if (cat === "POS") return pairedIsPleasant ? targetKey : otherKey;
          if (cat === "NEG") return pairedIsPleasant ? otherKey : targetKey;
          throw new Error("Unknown category: " + cat);
        },
        titles: () => {
          // Build the header box titles to match mapping
          // Determine what left/right keys represent
          const leftCats = [];
          const rightCats = [];

          // which side is target key?
          const targetKeyIsLeft = (targetSide === "left");

          if (targetKeyIsLeft){
            // left has TARGET + (POS if LD+PLE else NEG)
            leftCats.push(TARGET_LABEL);
            leftCats.push(pairedIsPleasant ? ATTR_POS_LABEL : ATTR_NEG_LABEL);
            rightCats.push(pairedIsPleasant ? ATTR_NEG_LABEL : ATTR_POS_LABEL);
          } else {
            // right has TARGET + (POS if LD+PLE else NEG)
            rightCats.push(TARGET_LABEL);
            rightCats.push(pairedIsPleasant ? ATTR_POS_LABEL : ATTR_NEG_LABEL);
            leftCats.push(pairedIsPleasant ? ATTR_NEG_LABEL : ATTR_POS_LABEL);
          }

          const leftTitle = leftCats.join(" + ");
          const rightTitle = rightCats.join(" + ");

          return { leftTitle, rightTitle };
        }
      };
    }

    function makeAttrPracticeVars(nTrials){
      const half = Math.floor(nTrials/2);
      const pos = pickTrials(POS_STIM, half).map(w => ({ stim: w, cat: "POS" }));
      const neg = pickTrials(NEG_STIM, nTrials-half).map(w => ({ stim: w, cat: "NEG" }));
      return shuffle(pos.concat(neg)).map(t => ({
        stimulus: renderIATScreen({
          leftTitle: ATTR_POS_LABEL,
          leftSub: "",
          rightTitle: ATTR_NEG_LABEL,
          rightSub: "",
          stimulus: t.stim
        }),
        category: t.cat,
        key_answer: (t.cat === "POS") ? KEYS.left : KEYS.right
      }));
    }

    function makeCombinedVars(nTrials, pairing, targetSide){
      const map = mappingFor(pairing, targetSide);
      const { leftTitle, rightTitle } = map.titles();

      // roughly 1/3 target, 1/3 pos, rest neg
      const nTarget = Math.round(nTrials/3);
      const nPos = Math.round(nTrials/3);
      const nNeg = nTrials - nTarget - nPos;

      const targets = pickTrials(TARGET_STIM, nTarget).map(w => ({ stim: w, cat: "TARGET" }));
      const pos = pickTrials(POS_STIM, nPos).map(w => ({ stim: w, cat: "POS" }));
      const neg = pickTrials(NEG_STIM, nNeg).map(w => ({ stim: w, cat: "NEG" }));

      return shuffle(targets.concat(pos, neg)).slice(0, nTrials).map(t => ({
        stimulus: renderIATScreen({
          leftTitle,
          leftSub: "",
          rightTitle,
          rightSub: "",
          stimulus: t.stim
        }),
        category: t.cat,
        pairing,
        targetSide,
        key_answer: map.keyFor(t.cat)
      }));
    }

    function stiatCategorizeBlock(blockName, vars){
      return {
        timeline: [{
          type: jsPsychCategorizeHtml,
          stimulus: jsPsych.timelineVariable("stimulus"),
          key_answer: () => jsPsych.timelineVariable("key_answer"),
          choices: [KEYS.left, KEYS.right],
          show_stim_with_feedback: true,
          feedback_duration: 250,
          correct_text: "",
          incorrect_text: `<div class="iat-errorX">X</div>`,
          prompt: "", // IMPORTANT: we already render the header boxes in stimulus HTML
          data: () => ({
            block: blockName,
            pairing: jsPsych.timelineVariable("pairing"),
            targetSide: jsPsych.timelineVariable("targetSide"),
            category: jsPsych.timelineVariable("category"),
          })
        }],
        timeline_variables: vars
      };
    }

    /**********************************************************************
     * BUILD EXACT BLOCKS (Wilson & Scior 5 blocks)
     **********************************************************************/
    const block1Vars = makeAttrPracticeVars(N_BLOCK1);

    const block2Vars = makeCombinedVars(N_BLOCK2, firstPairing, targetKeyFirst);
    const block3Vars = makeCombinedVars(N_BLOCK3, firstPairing, targetKeyFirst);  // scored
    const block4Vars = makeCombinedVars(N_BLOCK4, secondPairing, targetKeySecond);
    const block5Vars = makeCombinedVars(N_BLOCK5, secondPairing, targetKeySecond); // scored

    /**********************************************************************
     * jsPsych INIT
     **********************************************************************/
    const jsPsych = initJsPsych({
      display_element: "jspsych-target",
      on_finish: async () => {
        const data = jsPsych.data.get().values();
        const catTrials = data.filter(d => d.trial_type === "categorize-html" && d.block);

        // Identify which of Blocks 3/5 is congruent (LD+Pleasant) vs incongruent (LD+Unpleasant)
        const b3Pair = catTrials.find(t => t.block === "B3_test")?.pairing;
        const b5Pair = catTrials.find(t => t.block === "B5_test")?.pairing;

        const congruentBlock = (b3Pair === CONGRUENT_PAIRING) ? "B3_test" : "B5_test";
        const incongruentBlock = (congruentBlock === "B3_test") ? "B5_test" : "B3_test";

        const score = computeD_WilsonScior(catTrials, congruentBlock, incongruentBlock);

        updateState(s => {
          s.iat.trials = catTrials.map(t => ({
            block: t.block,
            pairing: t.pairing,
            targetSide: t.targetSide,
            stimulus: t.stimulus,
            category: t.category,
            correct: t.correct,
            rt: t.rt,
            response: t.response,
            ts: new Date().toISOString()
          }));
          s.iat.summary = {
            kind: "Wilson & Scior (2015) ST-IAT replication",
            firstPairing,
            secondPairing,
            targetKeyFirst,
            targetKeySecond,
            congruentPairing: CONGRUENT_PAIRING,
            D: score.D,
            meanCong: score.meanCong,
            meanIncong: score.meanIncong,
            sdAll: score.sdAll,
            nUsed: score.nUsed
          };
          return s;
        });

        window.location.href = "self-report.html";
      }
    });

    /**********************************************************************
     * TIMELINE
     **********************************************************************/
    const preload = { type: jsPsychPreload, auto_preload: true };

    const welcome = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <div class="card" style="border:none; box-shadow:none;">
          <h2 style="margin-top:0;">Instructions</h2>
          <p>Respond as quickly and accurately as possible.</p>
          <p>Use <span class="kbd">E</span> for LEFT and <span class="kbd">I</span> for RIGHT.</p>
          <p>Press any key to begin.</p>
        </div>
      `
    };

    const block1Instr = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <p><strong>Block 1</strong> (practice)</p>
        <p>Sort words into <strong>${ATTR_POS_LABEL}</strong> (E) and <strong>${ATTR_NEG_LABEL}</strong> (I).</p>
        <p>Press any key to start.</p>
      `
    };

    const block2Instr = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <p><strong>Block 2</strong> (practice)</p>
        <p>Now you will also see <strong>${TARGET_LABEL}</strong> words.</p>
        <p>Use the category labels at the top of the screen.</p>
        <p>Press any key to start.</p>
      `
    };

    const block4Instr = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <p><strong>Block 4</strong> (practice)</p>
        <p>The response key for <strong>${TARGET_LABEL}</strong> has switched.</p>
        <p>Use the category labels at the top of the screen.</p>
        <p>Press any key to start.</p>
      `
    };

    const timeline = [];
    timeline.push(preload, welcome);

    // Block 1
    timeline.push(block1Instr, stiatCategorizeBlock("B1_attr_practice", block1Vars));

    // Blocks 2–3
    timeline.push(block2Instr,
      stiatCategorizeBlock("B2_practice", block2Vars),
      stiatCategorizeBlock("B3_test", block3Vars)
    );

    // Blocks 4–5
    timeline.push(block4Instr,
      stiatCategorizeBlock("B4_practice", block4Vars),
      stiatCategorizeBlock("B5_test", block5Vars)
    );

    // Anti-back soft lock
    history.pushState(null, "", location.href);
    window.addEventListener("popstate", () => history.pushState(null, "", location.href));

    jsPsych.run(timeline);
  </script>
</body>
</html>
